'''
1. Проанализировать скорость и сложность одного любого алгоритма, разработанных в рамках домашнего задания
первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

возьмем задачу 2.7
7. Напишите программу, доказывающую или проверяющую,
 что для множества натуральных чисел выполняется равенство: 1+2+...+n = n(n+1)/2,
 где n - любое натуральное число.
'''
import time

#декоратор из примера с урока
def time_func(func):
    def wrapper():
        start_time = time.time()
        res = func()
        end_time =  time.time()
        print('Время исполнения', end_time-start_time)
        return res
    return wrapper

# Асимптотическая сложность функции: O(2^N), так как рекурсия, то есть функция в худшем случае будет вызываться n раз
# Пространственная сложность: О(1) - так как создаем только 1 дополнительную переменную n.
def first_part(n):
    if n == 1:
        return 1
    elif n > 0:
        return n + first_part(n - 1)
    else:
        return -1

# время работы 2.9799999999996496e-05
a = time.perf_counter()
print(first_part(5))
b = time.perf_counter()
dif = b-a
print(dif)

# Асимптотическая сложность: O(1), так как при любом значении n алгоритм отработает одинаково
# Пространственная сложность: О(1) - так как создаем только 1 дополнительную переменную n.
def second_part(n):
    return n * (n + 1 ) // 2

#def check_func() - Асимптотическая сложность: O(N) * O(2^N) * O(1),
# так как O(N) - цикл while отработает 994 раза (n=994), O(2^N) - first_part(n), O(1) - second_part(n)
#Итого общая сложность алгоритма O(2^N * N)
# Пространственная сложность: О(1) - так как создаем только 1 дополнительную переменную n.
@time_func
def check_func():
    n = 1
    #сделаем проверку до 995, потом ломается
    while n < 995:
        if first_part(n) == second_part(n):
            print(f'Для n {n} - True')
        else:
            print(f'Для n {n} - False')
            break
        n = n + 1


# Перепишем первую функцию, чтобы избавиться от рекурсии
# Асимптотическая сложность: O(N), так как проходимся по списку из n элементов.
# Данная функция работает бытрее первоначальной примерно в 2 раза
# Пространственная сложность: О(N) - так как создаем только список длиной n.
def first_part_no_rec(n):
    return sum(list(range(n+1)))

# время работы 1.559999999999756e-05
a = time.perf_counter()
print(first_part_no_rec(5))
b = time.perf_counter()
dif_1 = b-a
print(dif_1)
print(f'Функуция first_part_no_rec работает быстрее, чем first_part в {round(dif/dif_1), 2} раза')

#Создадим новую функцию для проверки.
#Тут ассимптотическая сложность O(N) * O(N) * O(1). Итого O(N^2)
# Пространственная сложность:
# О(N) - first_part_no_rec так как создаем только список длиной n.
# О(1) - second_part так как создаем только 1 дополнительную переменную n.
# О(1) - new_check_func, так как создаем только 1 дополнительную переменную n.
# Итого пространственная сложность О(N)+О(1)+О(1) = O(N+1+1) =O(N)
@time_func
def new_check_func():
    n = 1
    #сделаем проверку до 995, потом ломается
    while n < 995:
        if first_part_no_rec(n) == second_part(n):
            print(f'Для n {n} - True')
        else:
            print(f'Для n {n} - False')
            break
        n = n + 1

#Время исполнения 0.5569427013397217
check_func()
#Время исполнения 0.05489349365234375
new_check_func()

'''
Убрала принты, время исполнения функций изменилось:
Время исполнения 0.2759733200073242 - check_func()
Время исполнения 0.030443668365478516 - new_check_func()
'''
